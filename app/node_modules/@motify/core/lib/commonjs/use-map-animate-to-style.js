"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = useMapAnimateToStyle;

var _framerMotion = require("framer-motion");

var _react = require("react");

var _reactNativeReanimated = require("react-native-reanimated");

var _packageName = require("./constants/package-name");

const debug = (...args) => {
  'worklet';

  if (args) {// hi
  } // console.log('[moti]', ...args)

};

const isColor = styleKey => {
  'worklet';

  return ['backgroundColor', 'borderBottomColor', 'borderColor', 'borderEndColor', 'borderLeftColor', 'borderRightColor', 'borderStartColor', 'borderTopColor', 'color'].includes(styleKey);
};

const isTransform = styleKey => {
  'worklet';

  const transforms = ['perspective', 'rotate', 'rotateX', 'rotateY', 'rotateZ', 'scale', 'scaleX', 'scaleY', 'translateX', 'translateY', 'skewX', 'skewY'];
  return transforms.includes(styleKey);
};

function animationDelay(key, transition, defaultDelay) {
  'worklet';

  var _ref;

  let delayMs = defaultDelay;

  if ((transition === null || transition === void 0 ? void 0 : (_ref = transition[key]) === null || _ref === void 0 ? void 0 : _ref.delay) != null) {
    var _ref2;

    delayMs = transition === null || transition === void 0 ? void 0 : (_ref2 = transition[key]) === null || _ref2 === void 0 ? void 0 : _ref2.delay;
  } else if ((transition === null || transition === void 0 ? void 0 : transition.delay) != null) {
    delayMs = transition.delay;
  }

  return {
    delayMs
  };
}

function animationConfig(styleProp, transition) {
  'worklet';

  var _ref3, _loop, _ref4, _ref5, _ref7;

  const key = styleProp;
  let repeatCount = 0;
  let repeatReverse = true;
  let animationType = 'spring';
  if (isColor(key) || key === 'opacity') animationType = 'timing'; // say that we're looking at `width`
  // first, check if we have transition.width.type

  if (transition !== null && transition !== void 0 && (_ref3 = transition[key]) !== null && _ref3 !== void 0 && _ref3.type) {
    var _key;

    animationType = (_key = transition[key]) === null || _key === void 0 ? void 0 : _key.type;
  } else if (transition !== null && transition !== void 0 && transition.type) {
    // otherwise, fallback to transition.type
    animationType = transition.type;
  }

  const loop = (_loop = transition === null || transition === void 0 ? void 0 : (_ref4 = transition[key]) === null || _ref4 === void 0 ? void 0 : _ref4.loop) !== null && _loop !== void 0 ? _loop : transition === null || transition === void 0 ? void 0 : transition.loop;

  if (loop != null) {
    repeatCount = loop ? -1 : 0;
  }

  if ((transition === null || transition === void 0 ? void 0 : (_ref5 = transition[key]) === null || _ref5 === void 0 ? void 0 : _ref5.repeat) != null) {
    var _ref6;

    repeatCount = transition === null || transition === void 0 ? void 0 : (_ref6 = transition[key]) === null || _ref6 === void 0 ? void 0 : _ref6.repeat;
  } else if ((transition === null || transition === void 0 ? void 0 : transition.repeat) != null) {
    repeatCount = transition.repeat;
  }

  if ((transition === null || transition === void 0 ? void 0 : (_ref7 = transition[key]) === null || _ref7 === void 0 ? void 0 : _ref7.repeatReverse) != null) {
    var _ref8;

    repeatReverse = transition === null || transition === void 0 ? void 0 : (_ref8 = transition[key]) === null || _ref8 === void 0 ? void 0 : _ref8.repeatReverse;
  } else if ((transition === null || transition === void 0 ? void 0 : transition.repeatReverse) != null) {
    repeatReverse = transition.repeatReverse;
  }

  debug({
    loop,
    key,
    repeatCount,
    animationType
  });
  let config = {}; // so sad, but fix it later :(

  let animation = (...props) => props;

  if (animationType === 'timing') {
    var _duration, _ref9, _easing, _ref10;

    const duration = (_duration = transition === null || transition === void 0 ? void 0 : (_ref9 = transition[key]) === null || _ref9 === void 0 ? void 0 : _ref9.duration) !== null && _duration !== void 0 ? _duration : transition === null || transition === void 0 ? void 0 : transition.duration;
    const easing = (_easing = transition === null || transition === void 0 ? void 0 : (_ref10 = transition[key]) === null || _ref10 === void 0 ? void 0 : _ref10.easing) !== null && _easing !== void 0 ? _easing : transition === null || transition === void 0 ? void 0 : transition.easing;

    if (easing) {
      config['easing'] = easing;
    }

    if (duration != null) {
      config['duration'] = duration;
    }

    animation = _reactNativeReanimated.withTiming;
  } else if (animationType === 'spring') {
    animation = _reactNativeReanimated.withSpring;
    config = {// solve the missing velocity bug in 2.0.0-rc.0
      // velocity: 2,
    };
    const configKeys = ['damping', 'mass', 'overshootClamping', 'restDisplacementThreshold', 'restSpeedThreshold', 'stiffness', 'velocity'];
    configKeys.forEach(configKey => {
      'worklet';

      var _transition$key;

      const styleSpecificConfig = transition === null || transition === void 0 ? void 0 : (_transition$key = transition[key]) === null || _transition$key === void 0 ? void 0 : _transition$key[configKey];
      const transitionConfigForKey = transition === null || transition === void 0 ? void 0 : transition[configKey];

      if (styleSpecificConfig != null) {
        config[configKey] = styleSpecificConfig;
      } else if (transitionConfigForKey != null) {
        config[configKey] = transitionConfigForKey;
      }
    });
  } else if (animationType === 'decay') {
    // TODO decay doesn't work for now
    console.error("[".concat(_packageName.PackageName, "]: You passed transition type: decay, but this isn't working for now. Honestly, not sure why yet. Try passing other transition fields, like clamp, velocity, and deceleration. If that solves it, please open an issue and let me know."));
    animation = _reactNativeReanimated.withDecay;
    config = {
      velocity: 2,
      deceleration: 2
    };
    const configKeys = ['clamp', 'velocity', 'deceleration'];
    configKeys.forEach(configKey => {
      'worklet'; // is this necessary ^ don't think so...?

      var _transition$key2;

      const styleSpecificConfig = transition === null || transition === void 0 ? void 0 : (_transition$key2 = transition[key]) === null || _transition$key2 === void 0 ? void 0 : _transition$key2[configKey];
      const transitionConfigForKey = transition === null || transition === void 0 ? void 0 : transition[configKey];

      if (styleSpecificConfig != null) {
        config[configKey] = styleSpecificConfig;
      } else if (transitionConfigForKey != null) {
        config[configKey] = transitionConfigForKey;
      }
    });
  }

  return {
    animation,
    config,
    repeatReverse,
    repeatCount,
    shouldRepeat: !!repeatCount
  };
}

function useMapAnimateToStyle({
  animate: animateProp,
  from: fromProp = false,
  transition: transitionProp,
  exitTransition: exitTransitionProp,
  delay: defaultDelay,
  state,
  stylePriority = 'animate',
  onDidAnimate,
  exit: exitProp,
  animateInitialState = false
}) {
  const isMounted = (0, _reactNativeReanimated.useSharedValue)(false);
  const [isPresent, safeToUnmount] = (0, _framerMotion.usePresence)();
  const presence = (0, _react.useContext)(_framerMotion.PresenceContext);
  const disableInitialAnimation = (presence === null || presence === void 0 ? void 0 : presence.initial) === false && !animateInitialState;
  const custom = (0, _react.useCallback)(() => {
    'worklet';

    return presence === null || presence === void 0 ? void 0 : presence.custom;
  }, [presence]);
  const reanimatedSafeToUnmount = (0, _react.useCallback)(() => {
    safeToUnmount === null || safeToUnmount === void 0 ? void 0 : safeToUnmount();
  }, [safeToUnmount]);
  const reanimatedOnDidAnimated = (0, _react.useCallback)((...args) => {
    onDidAnimate === null || onDidAnimate === void 0 ? void 0 : onDidAnimate(...args);
  }, [onDidAnimate]);
  const hasExitStyle = !!(typeof exitProp === 'function' || typeof exitProp === 'object' && exitProp && Object.keys(exitProp).length > 0);
  const style = (0, _reactNativeReanimated.useAnimatedStyle)(() => {
    var _state$__state;

    const final = {
      // initializing here fixes reanimated object.__defineProperty bug(?)
      transform: []
    };
    const variantStyle = (state === null || state === void 0 ? void 0 : (_state$__state = state.__state) === null || _state$__state === void 0 ? void 0 : _state$__state.value) || {};
    let animateStyle;

    if (animateProp && 'value' in animateProp) {
      animateStyle = animateProp.value || {};
    } else {
      animateStyle = animateProp || {};
    }

    const initialStyle = fromProp || {};
    let exitStyle = exitProp || {};

    if (typeof exitStyle === 'function') {
      exitStyle = exitStyle(custom());
    }

    const isExiting = !isPresent && hasExitStyle;
    let mergedStyles = {};

    if (stylePriority === 'state') {
      mergedStyles = Object.assign({}, animateStyle, variantStyle);
    } else {
      mergedStyles = Object.assign({}, variantStyle, animateStyle);
    }

    if (!isMounted.value && !disableInitialAnimation && Object.keys(initialStyle).length) {
      mergedStyles = initialStyle;
    } else {
      mergedStyles = Object.assign({}, initialStyle, mergedStyles);
    }

    if (isExiting && exitStyle) {
      mergedStyles = Object.assign({}, exitStyle);
    }

    debug('here'); // reduce doesn't work with spreads/reanimated Objects!
    // const exitingStyleProps: Record<string, boolean> = Object.keys(
    //   mergedStyles || {}
    // ).reduce((obj, styleKey) => ({ ...obj, [styleKey]: true }), {})
    // use forEach instead!

    const exitingStyleProps = {};
    Object.keys(exitStyle || {}).forEach(key => {
      exitingStyleProps[key] = true;
    }); // allow shared values as transitions

    let transition;

    if (transitionProp && 'value' in transitionProp) {
      transition = transitionProp.value;
    } else {
      transition = transitionProp;
    }

    if (isExiting && exitTransitionProp) {
      let exitTransition;

      if (exitTransitionProp && 'value' in exitTransitionProp) {
        exitTransition = exitTransitionProp.value;
      } else {
        exitTransition = exitTransitionProp;
      }

      transition = Object.assign({}, transition, exitTransition);
    }

    const transformKeys = Object.keys(mergedStyles).filter(key => isTransform(key));

    if (transformKeys.length > 1) {
      console.error("[".concat(_packageName.PackageName, "] Multiple inline transforms found. This won't animate properly. Instead, pass these to a transform array: ").concat(transformKeys.join(', ')));
    }

    Object.keys(mergedStyles).forEach(key => {
      // const initialValue = initialStyle[key]
      const value = mergedStyles[key];
      const {
        animation,
        config,
        shouldRepeat,
        repeatCount,
        repeatReverse
      } = animationConfig(key, transition);

      const callback = (completed, recentValue) => {
        if (onDidAnimate) {
          (0, _reactNativeReanimated.runOnJS)(reanimatedOnDidAnimated)(key, completed, recentValue, {
            attemptedValue: value
          });
        }

        if (isExiting) {
          exitingStyleProps[key] = false;
          const areStylesExiting = Object.values(exitingStyleProps).some(Boolean); // if this is true, then we've finished our exit animations

          if (!areStylesExiting) {
            (0, _reactNativeReanimated.runOnJS)(reanimatedSafeToUnmount)();
          }
        }
      };

      let {
        delayMs
      } = animationDelay(key, transition, defaultDelay);

      if (value == null || value === false) {
        // skip missing values
        // this is useful if you want to do {opacity: loading && 1}
        // without this, those values will break I think
        return;
      }

      const getSequenceArray = (sequenceKey, sequenceArray) => {
        'worklet';

        const sequence = sequenceArray.filter(step => {
          // remove null, false values to allow for conditional styles
          if (step && typeof step === 'object') {
            return (step === null || step === void 0 ? void 0 : step.value) != null && (step === null || step === void 0 ? void 0 : step.value) !== false;
          }

          return step != null && step !== false;
        }).map(step => {
          let stepDelay = delayMs;
          let stepValue = step;
          let stepConfig = Object.assign({}, config);
          let stepAnimation = animation;

          if (typeof step === 'object') {
            // not allowed in Reanimated: { delay, value, ...transition } = step
            const stepTransition = Object.assign({}, step);
            delete stepTransition.delay;
            delete stepTransition.value;
            const {
              config: inlineStepConfig,
              animation
            } = animationConfig(sequenceKey, stepTransition);
            stepConfig = Object.assign({}, stepConfig, inlineStepConfig);
            stepAnimation = animation;

            if (step.delay != null) {
              stepDelay = step.delay;
            }

            stepValue = step.value;
          }

          const sequenceValue = stepAnimation(stepValue, stepConfig, callback);

          if (stepDelay != null) {
            return (0, _reactNativeReanimated.withDelay)(stepDelay, sequenceValue);
          }

          return sequenceValue;
        }).filter(Boolean);
        return sequence;
      };

      if (key === 'transform') {
        if (!Array.isArray(value)) {
          console.error("[".concat(_packageName.PackageName, "]: Invalid transform value. Needs to be an array."));
        } else {
          value.forEach(transformObject => {
            final['transform'] = final['transform'] || [];
            const transformKey = Object.keys(transformObject)[0];
            const transformValue = transformObject[transformKey];
            const transform = {};

            if (Array.isArray(transformValue)) {
              // we have a sequence in this transform...
              const sequence = getSequenceArray(transformKey, transformValue);

              if (sequence.length) {
                let finalValue = (0, _reactNativeReanimated.withSequence)(sequence[0], ...sequence.slice(1));

                if (shouldRepeat) {
                  finalValue = (0, _reactNativeReanimated.withRepeat)(finalValue, repeatCount, repeatReverse);
                }

                transform[transformKey] = finalValue;
              }
            } else {
              var _transition, _transition$transform;

              if (((_transition = transition) === null || _transition === void 0 ? void 0 : (_transition$transform = _transition[transformKey]) === null || _transition$transform === void 0 ? void 0 : _transition$transform.delay) != null) {
                var _transition2, _transition2$transfor;

                delayMs = (_transition2 = transition) === null || _transition2 === void 0 ? void 0 : (_transition2$transfor = _transition2[transformKey]) === null || _transition2$transfor === void 0 ? void 0 : _transition2$transfor.delay;
              }

              let finalValue = animation(transformValue, config, callback);

              if (shouldRepeat) {
                finalValue = (0, _reactNativeReanimated.withRepeat)(finalValue, repeatCount, repeatReverse);
              }

              if (delayMs != null) {
                transform[transformKey] = (0, _reactNativeReanimated.withDelay)(delayMs, finalValue);
              } else {
                transform[transformKey] = finalValue;
              }
            }

            if (Object.keys(transform).length) {
              final['transform'].push(transform);
            }
          });
        }
      } else if (Array.isArray(value)) {
        // we have a sequence
        const sequence = getSequenceArray(key, value);
        let finalValue = (0, _reactNativeReanimated.withSequence)(sequence[0], ...sequence.slice(1));

        if (shouldRepeat) {
          finalValue = (0, _reactNativeReanimated.withRepeat)(finalValue, repeatCount, repeatReverse);
        }

        if (isTransform(key)) {
          // we have a sequence of transforms
          final['transform'] = final['transform'] || [];

          if (sequence.length) {
            const transform = {};
            transform[key] = finalValue; // @ts-expect-error transform had the wrong type

            final['transform'].push(transform);
          }
        } else {
          // we have a normal sequence of items
          // shadows not supported
          if (sequence.length) {
            final[key] = finalValue;
          }
        }
      } else if (isTransform(key)) {
        var _transition3, _transition3$key;

        final['transform'] = final['transform'] || []; // const transformKey = Object.keys(transformProp)[0]
        // const transformValue = transformProp[transformKey]

        if (((_transition3 = transition) === null || _transition3 === void 0 ? void 0 : (_transition3$key = _transition3[key]) === null || _transition3$key === void 0 ? void 0 : _transition3$key.delay) != null) {
          var _transition4, _transition4$key;

          delayMs = (_transition4 = transition) === null || _transition4 === void 0 ? void 0 : (_transition4$key = _transition4[key]) === null || _transition4$key === void 0 ? void 0 : _transition4$key.delay;
        }

        const transform = {};
        let finalValue = animation(value, config, callback);

        if (shouldRepeat) {
          finalValue = (0, _reactNativeReanimated.withRepeat)(finalValue, repeatCount, repeatReverse);
        }

        if (delayMs != null) {
          transform[key] = (0, _reactNativeReanimated.withDelay)(delayMs, finalValue);
        } else {
          transform[key] = finalValue;
        } // @ts-expect-error transform had the wrong type


        final['transform'].push(transform);
      } else if (typeof value === 'object') {
        // shadows
        final[key] = {};
        Object.keys(value || {}).forEach(innerStyleKey => {
          let finalValue = animation(value, config, callback);

          if (shouldRepeat) {
            finalValue = (0, _reactNativeReanimated.withRepeat)(finalValue, repeatCount, repeatReverse);
          }

          if (delayMs != null) {
            final[key][innerStyleKey] = (0, _reactNativeReanimated.withDelay)(delayMs, finalValue);
          } else {
            final[key][innerStyleKey] = finalValue;
          }
        });
      } else {
        let finalValue = animation(value, config, callback);

        if (shouldRepeat) {
          finalValue = (0, _reactNativeReanimated.withRepeat)(finalValue, repeatCount, repeatReverse);
        }

        if (delayMs != null && typeof delayMs === 'number') {
          final[key] = (0, _reactNativeReanimated.withDelay)(delayMs, finalValue);
        } else {
          final[key] = finalValue;
        }
      }
    }); // TODO
    // if (!final.transform?.length) {
    //   delete final.transform
    // }

    return final;
  });
  (0, _react.useEffect)(() => {
    isMounted.value = true;
  }, [isMounted]);
  (0, _react.useEffect)(function allowUnMountIfMissingExit() {
    if (!isPresent && !hasExitStyle) {
      reanimatedSafeToUnmount();
    }
  }, [hasExitStyle, isPresent, reanimatedSafeToUnmount]);
  return {
    style
  };
}
//# sourceMappingURL=use-map-animate-to-style.js.map